<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>刷题记录--数组小结</title>
    <url>/2022/10/02/LEETCODE/about-array/</url>
    <content><![CDATA[<p>数组小结部分Carl哥总结的特别好，这里直接引用他的总结思维导图<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" style="zoom:200%;"></p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题记录--模拟行为（矩阵相关）</title>
    <url>/2022/10/02/LEETCODE/spiral-matrix/</url>
    <content><![CDATA[<h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></h4><p>难度中等836收藏分享切换为英文接收动态反馈</p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h4><p>难度中等1224收藏分享切换为英文接收动态反馈</p>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>Array</category>
        <category>Matrix</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题记录--滑动窗口相关</title>
    <url>/2022/10/01/LEETCODE/sliding-windows/</url>
    <content><![CDATA[<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h4><p>难度中等1393收藏分享切换为英文接收动态反馈</p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<p>解法1:暴力解法，两个循环遍历时间复杂度O(n^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 定义一个无限大的数</span></span><br><span class="line">        res = float(<span class="string">"inf"</span>)</span><br><span class="line">        Sum = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            Sum += nums[i]</span><br><span class="line">            <span class="keyword">while</span> Sum &gt;= s:</span><br><span class="line">                res = min(res, i-index+<span class="number">1</span>)</span><br><span class="line">                Sum -= nums[index]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res==float(<span class="string">"inf"</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<p>解法2: <a href="https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95" target="_blank" rel="noopener">滑动窗口参见Carl</a></p>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。那么问题来了， 滑动窗口的起始位置如何移动呢？这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p>
<p>最后找到 4，3 是最短距离。</p>
<p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。解题的关键在于 窗口的起始位置如何移动，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt=""></p>
<p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#滑动窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, target: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(nums)==<span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        lenf=len(nums)+<span class="number">1</span></span><br><span class="line">        total=<span class="number">0</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (j&lt;len(nums)):</span><br><span class="line">            total=total+nums[j]</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (total&gt;=target):</span><br><span class="line">                lenf=min(lenf,j-i)</span><br><span class="line">                total=total-nums[i]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lenf==len(nums)+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> lenf</span><br></pre></td></tr></table></figure>
<h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/" target="_blank" rel="noopener">904. 水果成篮</a></h4><p>难度中等277收藏分享切换为英文接收动态反馈</p>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= fruits.length &lt;= 105</code></li>
<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>
</ul>
<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><p>难度困难2175收藏分享切换为英文接收动态反馈</p>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &apos;a&apos; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>Array</category>
        <category>sliding_windows</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题记录--双指针系列1</title>
    <url>/2022/10/01/LEETCODE/array-tags/</url>
    <content><![CDATA[<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></h4><p>难度简单1506收藏分享切换为英文接收动态反馈</p>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<p>题解：双指针解决</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val):</span><br><span class="line">                nums[slow] = nums[fast] </span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除有序数组中的重复项</a></h4><p>难度简单2859收藏分享切换为英文接收动态反馈</p>
<p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。</p>
<p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p>
<p>不要使用额外的空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>升序</strong> 排列</li>
</ul>
<p>题解：双指针，定义两个指针fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。假设数组 nums 的长度为 n。将快指针 fast 依次遍历从 1 到 n-1 的每个位置，对于每个位置，如果 nums[fast] != nums[fast-1]说明 nums[fast] 和之前的元素都不同，因此将nums[fast] 的值复制到 nums[slow]，然后将slow 的值加 1，即指向下一个位置。</p>
<p>遍历结束之后，从 nums[0] 到nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为slow，返回slow 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        slow, fast =  <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; len(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[fast<span class="number">-1</span>]):</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)，其中 n<em>n</em> 是数组的长度。快指针和慢指针最多各移动 <em>n</em>次。</li>
<li>空间复杂度：O(1)。只需要使用常数的额外空间。</li>
</ul>
<h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h4><p>难度简单1749收藏分享切换为英文接收动态反馈</p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<p>解法一：快慢指针，然后后面补0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> ;</span><br><span class="line">        slow = fast = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; len(nums)):</span><br><span class="line">            <span class="keyword">if</span> (nums[fast]!= <span class="number">0</span>):</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(slow &lt; len(nums)):</span><br><span class="line">            nums[slow] = <span class="number">0</span></span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<p>解法二：直接交换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[right] != <span class="number">0</span>:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode.cn/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></h4><p>难度简单526收藏分享切换为英文接收动态反馈</p>
<p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p>
<p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;ac&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s 和 t 都会变成 &quot;&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a#c&quot;, t = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：s 会变成 &quot;c&quot;，但 t 仍然是 &quot;b&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 200</code></li>
<li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以用 <code>O(n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>
</ul>
<p>解法一：利用栈来处理。最容易想到的方法是将给定的字符串中的退格符和应当被删除的字符都去除，还原给定字符串的一般形式。然后直接比较两字符串是否相等即可。具体地，我们用栈处理遍历过程，每次我们遍历到一个字符：如果它是退格符，那么我们将栈顶弹出；如果它是普通字符，那么我们将其压入栈中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, S: str, T: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(s: str)</span> -&gt; str:</span></span><br><span class="line">            ret = list()</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> ch != <span class="string">"#"</span>:</span><br><span class="line">                    ret.append(ch)</span><br><span class="line">                <span class="keyword">elif</span> ret:</span><br><span class="line">                    ret.pop()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>.join(ret)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> build(S) == build(T)</span><br></pre></td></tr></table></figure>
<p>解法二：双指针实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, S: str, T: str)</span> -&gt; bool:</span></span><br><span class="line">        i, j = len(S) - <span class="number">1</span>, len(T) - <span class="number">1</span></span><br><span class="line">        skipS = skipT = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> S[i] == <span class="string">"#"</span>:</span><br><span class="line">                    skipS += <span class="number">1</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> skipS &gt; <span class="number">0</span>:</span><br><span class="line">                    skipS -= <span class="number">1</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> T[j] == <span class="string">"#"</span>:</span><br><span class="line">                    skipT += <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> skipT &gt; <span class="number">0</span>:</span><br><span class="line">                    skipT -= <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> S[i] != T[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a></h4><p>难度简单640收藏分享切换为英文接收动态反馈</p>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li>
</ul>
<p>解法1：暴力求解，直接算平方再排序，时间复杂度O(N+NlogN)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> ;</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(index &lt; len(nums)):</span><br><span class="line">            nums[index] *= nums[index]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            <span class="comment">#sort(nums)</span></span><br><span class="line">        <span class="comment">#return(nums)</span></span><br><span class="line">        <span class="keyword">return</span> sorted(nums)</span><br><span class="line">        </span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">      ⚠️sorted和nums.sort()区别</span></span><br><span class="line"><span class="string">      1. sort 是应用在 list 上的方法，而sorted 可以对所有可迭代的对象进行排序操作；</span></span><br><span class="line"><span class="string">			2. sort是对原有列表进行操作，而sorted返回的是一个新的可迭代对象，不会改变原来的对象；</span></span><br><span class="line"><span class="string">			3. sort使用方法为list.sort()， 而sorted的使用方法为sorted(list)</span></span><br><span class="line"><span class="string">			sort()方法是在原地对列表排序，是对原列表的直接操作，并不会返回一个新的列表。sort()方法需要单独使用，如果和赋值，打印等方法一起使用，结果会返回None 。</span></span><br><span class="line"><span class="string">      '''</span></span><br></pre></td></tr></table></figure>
<p>解法2：双指针，判断左侧和右侧的平方哪个大，则加入新建的结果集中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> ;</span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span> </span><br><span class="line">        rst = []</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            <span class="keyword">if</span> nums[left]*nums[left] &gt;= nums[right]*nums[right]:</span><br><span class="line">                rst.append(nums[left]*nums[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rst.append(nums[right]*nums[right])</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>(rst[::<span class="number">-1</span>])</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 自己写的，最后需要逆序输出</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i,j,k = <span class="number">0</span>,n - <span class="number">1</span>,n - <span class="number">1</span></span><br><span class="line">        ans = [<span class="number">-1</span>] * n</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            lm = nums[i] ** <span class="number">2</span></span><br><span class="line">            rm = nums[j] ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> lm &gt; rm:</span><br><span class="line">                ans[k] = lm</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[k] = rm</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>Array</category>
        <category>double_pointer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题记录--二分查找相关相关</title>
    <url>/2022/09/30/LEETCODE/binary_search/</url>
    <content><![CDATA[<h3 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h3><h4 id="二分查找相关题目汇总"><a href="#二分查找相关题目汇总" class="headerlink" title="二分查找相关题目汇总"></a>二分查找相关题目汇总</h4><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></h4><p>   难度简单1001收藏分享切换为英文接收动态反馈</p>
<p>   给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p>   <strong>示例 1:</strong></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p>   <strong>示例 2:</strong></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p>   <strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<p>  解析，两种方法，注意区间闭合情况，共三处不同，right初始值，while循环条件和right赋值情况(要简略就三个条件都简略，没有➖1没有等于) 复杂度n log n</p>
<ol>
<li><p>区间左闭右开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        middle = (left + right) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">            left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">            right = middle</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nums = [-1,0,3,5,9,12]</span></span><br><span class="line"><span class="comment"># target = 2</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>]</span><br><span class="line">target = <span class="number">9</span></span><br><span class="line"><span class="comment"># search(nums,5)</span></span><br><span class="line">print(search(nums,target))</span><br></pre></td></tr></table></figure>
</li>
<li><p>区间左闭右闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(nums, target)</span>:</span></span><br><span class="line"></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span> </span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target):</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (nums[mid] &gt; target):</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h4><p>难度简单1734收藏分享切换为英文接收动态反馈</p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p>题解：本质还是二分查找，⚠️二分查找没找到结果，一定是下面代码中left = right时跳出循环，故直接返回即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target):</span><br><span class="line">            left = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">elif</span> (nums[mid] &gt; target):</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">target = <span class="number">2</span></span><br><span class="line">print(searchInsert(nums, target))</span><br></pre></td></tr></table></figure>
<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>难度中等1929收藏分享切换为英文接收动态反馈</p>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p>题解：三种解法：</p>
<p>解法一：两个二分搜索</p>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==null) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        res[<span class="number">0</span>] = findFirst(nums, target);</span><br><span class="line">        res[<span class="number">1</span>] = findLast(nums, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：一个二分搜索，然后左右微调滑动窗口</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">biarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">            left, right = <span class="number">0</span>, len(nums)</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target):</span><br><span class="line">                    right = mid </span><br><span class="line">                <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">                    left = mid + <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        index = biarySearch(nums,target)</span><br><span class="line">        left,right = index,index</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span>([<span class="number">-1</span>,<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">while</span> left <span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[left - <span class="number">1</span>] == target :</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right+<span class="number">1</span> &lt; len(nums) <span class="keyword">and</span> nums[right+<span class="number">1</span>] == target:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [left,right]</span><br></pre></td></tr></table></figure>
<p>解法三：没看懂？</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、首先，在 nums 数组中二分查找得到第一个大于等于 target的下标leftBorder；</span></span><br><span class="line"><span class="comment"># 2、在 nums 数组中二分查找得到第一个大于等于 target+1的下标， 减1则得到rightBorder；</span></span><br><span class="line"><span class="comment"># 3、如果开始位置在数组的右边或者不存在target，则返回[-1, -1] 。否则返回[leftBorder, rightBorder]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums:List[int], target:int)</span> -&gt; int:</span></span><br><span class="line">            left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right: <span class="comment"># 不变量：左闭右闭区间</span></span><br><span class="line">                middle = left + (right-left) //<span class="number">2</span> </span><br><span class="line">                <span class="keyword">if</span> nums[middle] &gt;= target: </span><br><span class="line">                    right = middle - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> left  <span class="comment"># 若存在target，则返回第一个等于target的值 </span></span><br><span class="line"></span><br><span class="line">        leftBorder = binarySearch(nums, target) <span class="comment"># 搜索左边界</span></span><br><span class="line">        rightBorder = binarySearch(nums, target+<span class="number">1</span>) <span class="number">-1</span>  <span class="comment"># 搜索右边界</span></span><br><span class="line">        <span class="keyword">if</span> leftBorder == len(nums) <span class="keyword">or</span> nums[leftBorder]!= target: <span class="comment"># 情况一和情况二</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> [leftBorder, rightBorder]</span><br></pre></td></tr></table></figure>
<h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根 </a></h4><p>难度简单1154收藏分享切换为英文接收动态反馈</p>
<p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p>
<p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p>
<p> <strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>
<p>   <strong>示例 1：</strong></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>   <strong>示例 2：</strong></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
<p>   <strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p>解法一：二分法，注意边界条件，注意循环终止条件，还像之前用左开右闭区间的话，缺少=条件，例如x=0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">0</span>, x </span><br><span class="line">        ans = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right):</span><br><span class="line">            mid = (left + right) // <span class="number">2</span> </span><br><span class="line">            <span class="keyword">if</span> (mid * mid &lt;= x):</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>解法二：牛顿迭代法</p>
<p><img src="https://raw.githubusercontent.com/Tonyan/picgo/main/images/image-20221001164722493.png" alt="image-20221001164722493"></p>
<p><img src="https://raw.githubusercontent.com/Tonyan/picgo/main/images/image-20221001164811043.png" alt="image-20221001164811043"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        C, x0 = float(x), float(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            xi = <span class="number">0.5</span> * (x0 + C / x0)</span><br><span class="line">            <span class="keyword">if</span> abs(x0 - xi) &lt; <span class="number">1e-7</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x0 = xi</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> int(x0)</span><br></pre></td></tr></table></figure>
<h4 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode.cn/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></h4><p>难度简单439收藏分享切换为英文接收动态反馈</p>
<p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>进阶：不要</strong> 使用任何内置的库函数，如 <code>sqrt</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num = 16</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num = 14</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 2^31 - 1</code></li>
</ul>
<p>题解：跟上题一样，两种解法，二分查找或者牛顿迭代 </p>
<p>二分查找，有mid就返回true，没有就返回false</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">0</span>, num </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (mid * mid &lt; num):</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (mid * mid &gt; num):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>牛顿迭代，返回计算的int(x)平方是否等于num</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x0,C = float(num),float(num)</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">            xi = <span class="number">0.5</span>*(x0+C/x0)</span><br><span class="line">            <span class="keyword">if</span> (abs(x0-xi)&lt; <span class="number">1e-7</span>):</span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            x0 = xi </span><br><span class="line">        <span class="keyword">return</span> int(x0)*int(x0)==num</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>Array</category>
        <category>binary search</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>ES 算法介绍</title>
    <url>/2022/09/25/RL/ES-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="ES算法介绍"><a href="#ES算法介绍" class="headerlink" title="ES算法介绍"></a>ES算法介绍</h3><p><img src="https://openai.com/content/images/2017/03/first-graphic-1.png" alt=""></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://openai.com/blog/evolution-strategies/" target="_blank" rel="noopener">https://openai.com/blog/evolution-strategies/</a></li>
<li><a href="https://blog.otoro.net/2017/10/29/visual-evolution-strategies/" target="_blank" rel="noopener">https://blog.otoro.net/2017/10/29/visual-evolution-strategies/</a></li>
<li><a href="https://lilianweng.github.io/posts/2019-09-05-evolution-strategies/" target="_blank" rel="noopener">https://lilianweng.github.io/posts/2019-09-05-evolution-strategies/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/189010215" target="_blank" rel="noopener">中文翻译1</a> <a href="https://baijiahao.baidu.com/s?id=1583737934335329818&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">中文翻译2</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/439253215" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/439253215</a></li>
<li><a href="https://www.jianshu.com/p/32292227d9d1" target="_blank" rel="noopener">https://www.jianshu.com/p/32292227d9d1</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26163640?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26163640?from_voters_page=true</a></li>
<li><a href="https://echenshe.com/class/ea/1-01-intro.html" target="_blank" rel="noopener">https://echenshe.com/class/ea/1-01-intro.html</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>RL</category>
      </categories>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>纠错算法总结</title>
    <url>/2020/03/05/%E7%BA%A0%E9%94%99%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>纠错中的错误类型描述：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d53436eba82d645e7b50b7479cf5bb7f_1440w.jpg" alt="img"></p>
<h3 id="技术概览"><a href="#技术概览" class="headerlink" title="技术概览"></a>技术概览</h3><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>自然语言处理综论（第二版）3.10拼写错误的检查与更正、3.11最小编辑距离</li>
<li><a href="https://zhuanlan.zhihu.com/p/112719984" target="_blank" rel="noopener">全面理解搜索Query：当你在搜索引擎中敲下回车后，发生了什么？</a></li>
<li><a href="https://github.com/shibing624/pycorrector" target="_blank" rel="noopener">pycorrector中文文本纠错工具</a></li>
</ol>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown中Latex常用语法</title>
    <url>/2020/03/05/%E2%80%9CMarkdown-latex-syntax%E2%80%9D/</url>
    <content><![CDATA[<h1 id="Markdown中Latex常用语法"><a href="#Markdown中Latex常用语法" class="headerlink" title="Markdown中Latex常用语法"></a>Markdown中Latex常用语法</h1><h2 id="常用希腊字母表"><a href="#常用希腊字母表" class="headerlink" title="常用希腊字母表"></a>常用希腊字母表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">Display</th>
<th>Capital Case</th>
<th style="text-align:center">Display</th>
<th>Var Case</th>
<th style="text-align:center">Display</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\alpha</code></td>
<td style="text-align:center">$\alpha$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\beta</code></td>
<td style="text-align:center">$\beta$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\gamma</code></td>
<td style="text-align:center">$\gamma$</td>
<td><code>\Gamma</code></td>
<td style="text-align:center">$\Gamma$</td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\theta</code></td>
<td style="text-align:center">$\theta$</td>
<td><code>\Theta</code></td>
<td style="text-align:center">$\Theta$</td>
<td><code>\vartheta</code></td>
<td style="text-align:center">$\vartheta$</td>
</tr>
<tr>
<td><code>\mu</code></td>
<td style="text-align:center">$\mu$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\delta</code></td>
<td style="text-align:center">$\delta$</td>
<td><code>\Delta</code></td>
<td style="text-align:center">$\Delta$</td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\epsilon</code></td>
<td style="text-align:center">$\epsilon$</td>
<td></td>
<td style="text-align:center"></td>
<td><code>\varepsilon</code></td>
<td style="text-align:center">$\varepsilon$</td>
</tr>
<tr>
<td><code>\sigma</code></td>
<td style="text-align:center">$\sigma$</td>
<td><code>\Sigma</code></td>
<td style="text-align:center">$\Sigma$</td>
<td><code>\varsigma</code></td>
<td style="text-align:center">$\varsigma$</td>
</tr>
<tr>
<td><code>\pi</code></td>
<td style="text-align:center">$\pi$</td>
<td><code>\Pi</code></td>
<td style="text-align:center">$\Pi$</td>
<td><code>\varpi</code></td>
<td style="text-align:center">$\varpi$</td>
</tr>
<tr>
<td><code>\omega</code></td>
<td style="text-align:center">$\omega$</td>
<td><code>\Omega</code></td>
<td style="text-align:center">$\Omega$</td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\xi</code></td>
<td style="text-align:center">$\xi$</td>
<td><code>\Xi</code></td>
<td style="text-align:center">$\Xi$</td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\zeta</code></td>
<td style="text-align:center">$\zeta$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\chi</code></td>
<td style="text-align:center">$\chi$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\rho</code></td>
<td style="text-align:center">$\rho$</td>
<td></td>
<td style="text-align:center"></td>
<td><code>\varrho</code></td>
<td style="text-align:center">$\varrho$</td>
</tr>
<tr>
<td><code>\phi</code></td>
<td style="text-align:center">$\phi$</td>
<td><code>\Phi</code></td>
<td style="text-align:center">$\Phi$</td>
<td><code>\varphi</code></td>
<td style="text-align:center">$\varphi$</td>
</tr>
<tr>
<td><code>\eta</code></td>
<td style="text-align:center">$\eta$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\lambda</code></td>
<td style="text-align:center">$\lambda$</td>
<td><code>\Lambda</code></td>
<td style="text-align:center">$\Lambda$</td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\kappa</code></td>
<td style="text-align:center">$\kappa$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\nu</code></td>
<td style="text-align:center">$\nu$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\upsilon</code></td>
<td style="text-align:center">$\upsilon$</td>
<td><code>\Upsilon</code></td>
<td style="text-align:center">$\Upsilon$</td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\psi</code></td>
<td style="text-align:center">$\psi$</td>
<td><code>\Psi</code></td>
<td style="text-align:center">$\Psi$</td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\tau</code></td>
<td style="text-align:center">$\tau$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>\iota</code></td>
<td style="text-align:center">$\iota$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><code>o</code></td>
<td style="text-align:center">$o$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="常用特殊字符表"><a href="#常用特殊字符表" class="headerlink" title="常用特殊字符表"></a>常用特殊字符表</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:center">Display</th>
<th>Name</th>
<th style="text-align:center">Display</th>
<th>Name</th>
<th style="text-align:center">Display</th>
<th>Name</th>
<th style="text-align:center">Display</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\times</code></td>
<td style="text-align:center">$\times$</td>
<td><code>\div</code></td>
<td style="text-align:center">$\div$</td>
<td><code>\pm</code></td>
<td style="text-align:center">$\pm$</td>
<td><code>\mp</code></td>
<td style="text-align:center">$\mp$</td>
</tr>
<tr>
<td style="text-align:left"><code>\otimes</code></td>
<td style="text-align:center">$\otimes$</td>
<td><code>\ominus</code></td>
<td style="text-align:center">$\ominus$</td>
<td><code>\oplus</code></td>
<td style="text-align:center">$\oplus$</td>
<td><code>\odot</code></td>
<td style="text-align:center">$\odot$</td>
</tr>
<tr>
<td style="text-align:left"><code>\oslash</code></td>
<td style="text-align:center">$\oslash$</td>
<td><code>\triangleq</code></td>
<td style="text-align:center">$\triangleq$</td>
<td><code>\ne</code></td>
<td style="text-align:center">$\ne$</td>
<td><code>\equiv</code></td>
<td style="text-align:center">$\equiv$</td>
</tr>
<tr>
<td style="text-align:left"><code>\lt</code></td>
<td style="text-align:center">$\lt$</td>
<td><code>\gt</code></td>
<td style="text-align:center">$\gt$</td>
<td><code>\le</code></td>
<td style="text-align:center">$\le$</td>
<td><code>\ge</code></td>
<td style="text-align:center">$\ge$</td>
</tr>
<tr>
<td style="text-align:left"><code>\cup</code></td>
<td style="text-align:center">$\cup$</td>
<td><code>\cap</code></td>
<td style="text-align:center">$\cap$</td>
<td><code>\Cup</code></td>
<td style="text-align:center">$\Cup$</td>
<td><code>\Cap</code></td>
<td style="text-align:center">$\Cap$</td>
</tr>
<tr>
<td style="text-align:left"><code>\bigcup</code></td>
<td style="text-align:center">$\bigcup$</td>
<td><code>\bigcap</code></td>
<td style="text-align:center">$\bigcap$</td>
<td><code>\ast</code></td>
<td style="text-align:center">$\ast$</td>
<td><code>\star</code></td>
<td style="text-align:center">$\star$</td>
</tr>
<tr>
<td style="text-align:left"><code>\bigotimes</code></td>
<td style="text-align:center">$\bigotimes$</td>
<td><code>\bigoplus</code></td>
<td style="text-align:center">$\bigoplus$</td>
<td><code>\circ</code></td>
<td style="text-align:center">$\circ$</td>
<td><code>\bullet</code></td>
<td style="text-align:center">$\bullet$</td>
</tr>
<tr>
<td style="text-align:left"><code>\bigcirc</code></td>
<td style="text-align:center">$\bigcirc$</td>
<td><code>\amalg</code></td>
<td style="text-align:center">$\amalg$</td>
<td><code>\to</code></td>
<td style="text-align:center">$\to$</td>
<td><code>\infty</code></td>
<td style="text-align:center">$\infty$</td>
</tr>
<tr>
<td style="text-align:left"><code>\vee</code></td>
<td style="text-align:center">$\vee$</td>
<td><code>\wedge</code></td>
<td style="text-align:center">$\wedge$</td>
<td><code>\lhd</code></td>
<td style="text-align:center">$\lhd$</td>
<td><code>\rhd</code></td>
<td style="text-align:center">$\rhd$</td>
</tr>
<tr>
<td style="text-align:left"><code>\bigvee</code></td>
<td style="text-align:center">$\bigvee$</td>
<td><code>\bigwedge</code></td>
<td style="text-align:center">$\bigwedge$</td>
<td><code>\unlhd</code></td>
<td style="text-align:center">$\unlhd$</td>
<td><code>\unrhd</code></td>
<td style="text-align:center">$\unrhd$</td>
</tr>
<tr>
<td style="text-align:left"><code>\sqcap</code></td>
<td style="text-align:center">$\sqcap$</td>
<td><code>\sqcup</code></td>
<td style="text-align:center">$\sqcup$</td>
<td><code>\prec</code></td>
<td style="text-align:center">$\prec$</td>
<td><code>\succ</code></td>
<td style="text-align:center">$\succ$</td>
</tr>
<tr>
<td style="text-align:left"><code>\subset</code></td>
<td style="text-align:center">$\subset$</td>
<td><code>\supset</code></td>
<td style="text-align:center">$\supset$</td>
<td><code>\sim</code></td>
<td style="text-align:center">$\sim$</td>
<td><code>\approx</code></td>
<td style="text-align:center">$\approx$</td>
</tr>
<tr>
<td style="text-align:left"><code>\subseteq</code></td>
<td style="text-align:center">$\subseteq$</td>
<td><code>\supseteq</code></td>
<td style="text-align:center">$\supseteq$</td>
<td><code>\cong</code></td>
<td style="text-align:center">$\cong$</td>
<td><code>\doteq</code></td>
<td style="text-align:center">$\doteq$</td>
</tr>
<tr>
<td style="text-align:left"><code>\setminus</code></td>
<td style="text-align:center">$\setminus$</td>
<td><code>\mid</code></td>
<td style="text-align:center">$\mid$</td>
<td><code>\ll</code></td>
<td style="text-align:center">$\ll$</td>
<td><code>\gg</code></td>
<td style="text-align:center">$\gg$</td>
</tr>
<tr>
<td style="text-align:left"><code>\parallel</code></td>
<td style="text-align:center">$\parallel$</td>
<td><code>\Join</code></td>
<td style="text-align:center">$\Join$</td>
<td><code>\in</code></td>
<td style="text-align:center">$\in$</td>
<td><code>\notin</code></td>
<td style="text-align:center">$\notin$</td>
</tr>
<tr>
<td style="text-align:left"><code>\propto</code></td>
<td style="text-align:center">$\propto$</td>
<td><code>\neg</code></td>
<td style="text-align:center">$\neg$</td>
<td><code>\ldots</code></td>
<td style="text-align:center">$\ldots$</td>
<td><code>\cdots</code></td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:left"><code>\forall</code></td>
<td style="text-align:center">$\forall$</td>
<td><code>\exists</code></td>
<td style="text-align:center">$\exists$</td>
<td><code>\vdots</code></td>
<td style="text-align:center">$\vdots$</td>
<td><code>\ddots</code></td>
<td style="text-align:center">$\ddots$</td>
</tr>
<tr>
<td style="text-align:left"><code>\aleph</code></td>
<td style="text-align:center">$\aleph$</td>
<td><code>\nabla</code></td>
<td style="text-align:center">$\nabla$</td>
<td><code>\imath</code></td>
<td style="text-align:center">$\imath$</td>
<td><code>\jmath</code></td>
<td style="text-align:center">$\jmath$</td>
</tr>
<tr>
<td style="text-align:left"><code>\ell</code></td>
<td style="text-align:center">$\ell$</td>
<td><code>\partial</code></td>
<td style="text-align:center">$\partial$</td>
<td><code>\int</code></td>
<td style="text-align:center">$\int$</td>
<td><code>\oint</code></td>
<td style="text-align:center">$\oint$</td>
</tr>
<tr>
<td style="text-align:left"><code>\uplus</code></td>
<td style="text-align:center">$\uplus$</td>
<td><code>\biguplus</code></td>
<td style="text-align:center">$\biguplus$</td>
<td>\infty</td>
<td style="text-align:center">$\infty$</td>
<td>\mathbb{R}</td>
<td style="text-align:center">$\mathbb{R}$</td>
</tr>
<tr>
<td style="text-align:left"><code>\in</code></td>
<td style="text-align:center">$\in$</td>
<td><code>\notin</code></td>
<td style="text-align:center">$\notin$</td>
<td><code>\setminus</code></td>
<td style="text-align:center">$\setminus$</td>
<td><code>\bigodot</code></td>
<td style="text-align:center">$\bigodot$</td>
</tr>
<tr>
<td style="text-align:left"><code>\prod</code></td>
<td style="text-align:center">$\prod$</td>
<td><code>\sum</code></td>
<td style="text-align:center">$\sum$</td>
<td></td>
<td style="text-align:center"></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">Display</th>
<th>Name</th>
<th style="text-align:center">Display</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\triangleleft</code></td>
<td style="text-align:center">$\triangleleft$</td>
<td><code>\triangleright</code></td>
<td style="text-align:center">$\triangleright$</td>
</tr>
<tr>
<td><code>\bigtriangleup</code></td>
<td style="text-align:center">$\bigtriangleup$</td>
<td><code>\bigtriangledown</code></td>
<td style="text-align:center">$\bigtriangledown$</td>
</tr>
<tr>
<td><code>\uparrow</code></td>
<td style="text-align:center">$\uparrow$</td>
<td><code>\downarrow</code></td>
<td style="text-align:center">$\downarrow$</td>
</tr>
<tr>
<td><code>\leftarrow</code></td>
<td style="text-align:center">$\leftarrow$</td>
<td><code>\rightarrow</code></td>
<td style="text-align:center">$\rightarrow$</td>
</tr>
<tr>
<td><code>\Leftarrow</code></td>
<td style="text-align:center">$\Leftarrow$</td>
<td><code>\Rightarrow</code></td>
<td style="text-align:center">$\Rightarrow$</td>
</tr>
<tr>
<td><code>\longleftarrow</code></td>
<td style="text-align:center">$\longleftarrow$</td>
<td><code>\longrightarrow</code></td>
<td style="text-align:center">$\longrightarrow$</td>
</tr>
<tr>
<td><code>\Longleftarrow</code></td>
<td style="text-align:center">$\Longleftarrow$</td>
<td><code>\Longrightarrow</code></td>
<td style="text-align:center">$\Longrightarrow$</td>
</tr>
<tr>
<td><code>\leftrightarrow</code></td>
<td style="text-align:center">$\leftrightarrow$</td>
<td><code>\longleftrightarrow</code></td>
<td style="text-align:center">$\longleftrightarrow$</td>
</tr>
<tr>
<td><code>\Leftrightarrow</code></td>
<td style="text-align:center">$\Leftrightarrow$</td>
<td><code>\Longleftrightarrow</code></td>
<td style="text-align:center">$\Longleftrightarrow$</td>
</tr>
<tr>
<td><code>\leftharpoonup</code></td>
<td style="text-align:center">$\leftharpoonup$</td>
<td><code>\rightharpoonup</code></td>
<td style="text-align:center">$\rightharpoonup$</td>
</tr>
<tr>
<td><code>\leftharpoondown</code></td>
<td style="text-align:center">$\leftharpoondown$</td>
<td><code>\rightharpoondown</code></td>
<td style="text-align:center">$\rightharpoondown$</td>
</tr>
<tr>
<td><code>\rightleftharpoons</code></td>
<td style="text-align:center">$\rightleftharpoons$</td>
<td><code>\S</code></td>
<td style="text-align:center">$\S$</td>
</tr>
<tr>
<td><code>\nwarrow</code></td>
<td style="text-align:center">$\nwarrow$</td>
<td><code>\nearrow</code></td>
<td style="text-align:center">$\nearrow$</td>
</tr>
<tr>
<td><code>\swarrow</code></td>
<td style="text-align:center">$\swarrow$</td>
<td><code>\searrow</code></td>
<td style="text-align:center">$\searrow$</td>
</tr>
<tr>
<td><code>\triangle</code></td>
<td style="text-align:center">$\triangle$</td>
<td><code>\box</code></td>
<td style="text-align:center">$\Box$</td>
</tr>
<tr>
<td><code>\diamond</code></td>
<td style="text-align:center">$\diamond$</td>
<td><code>\diamondsuit</code></td>
<td style="text-align:center">$\diamondsuit$</td>
</tr>
<tr>
<td><code>\heartsuit</code></td>
<td style="text-align:center">$\heartsuit$</td>
<td><code>\clubsuit</code></td>
<td style="text-align:center">$\clubsuit$</td>
</tr>
<tr>
<td><code>\spadesuit</code></td>
<td style="text-align:center">$\spadesuit$</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用公式／表示"><a href="#常用公式／表示" class="headerlink" title="常用公式／表示"></a>常用公式／表示</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>Display</th>
<th>Name</th>
<th>Display</th>
</tr>
</thead>
<tbody>
<tr>
<td>上下标<code>y = x_i^{a_1^2}</code></td>
<td><script type="math/tex">y = x_i^{a_1^2}</script></td>
<td>平方<code>y = x^2 \; \mbox{(二次函数)}</code></td>
<td><script type="math/tex">y = x^2 \; \mbox{(二次函数)}</script></td>
</tr>
<tr>
<td>间隔<code>a\,b $$ $$ a\;b $$ $$ a\quad b $$ $$ a\qquad b $$</code></td>
<td><script type="math/tex">ab</script> <script type="math/tex">a\,b</script> <script type="math/tex">a\;b</script> <script type="math/tex">a\quad b</script> <script type="math/tex">a\qquad b</script></td>
<td><code>开方\sqrt[3]{x+y}</code></td>
<td>$\sqrt[3]{x+y}$</td>
</tr>
<tr>
<td>平均<code>\overline{xyz} \mbox{ 或 } \bar{x}</code></td>
<td><script type="math/tex">\overline{xyz} \mbox{ 或 } \bar{x}</script></td>
<td>下划线<code>\underline{ABC}</code></td>
<td><script type="math/tex">\underline{ABC}</script></td>
</tr>
<tr>
<td>分数<code>\frac{b}{a}、\frac{x}{y}、\frac{1}{x+1}</code></td>
<td>$\frac{b}{a}、\frac{x}{y}、\frac{1}{x+1}$</td>
<td>矢量<code>\vec{a}</code></td>
<td>$\vec{a}$</td>
</tr>
<tr>
<td>点乘<code>a \cdot b</code> 星乘<code>a \ast b</code></td>
<td>$a \cdot b$ 、$a \ast b$</td>
<td>极限<code>\lim \limits_{a \searrow 0} (A^\top A + \alpha I)</code></td>
<td>$\lim \limits_{a \searrow 0} (A^\top A + \alpha I)$</td>
</tr>
<tr>
<td>积分<code>\int_{-\infty}^{+\infty} f(x) \mathrm{d}x</code></td>
<td><script type="math/tex">\int_{-\infty}^{+\infty} f(x) \mathrm{d}x</script></td>
<td>行内积分limit模式<code>\int\limits_{-\infty}^{+\infty} f(x) \mathrm{d}x</code></td>
<td>$\int\limits_{-\infty}^{+\infty} f(x) \mathrm{d}x$</td>
</tr>
<tr>
<td>双重积分display模式<code>\displaystyle\iint_{-\infty}^{+\infty} f(x,y) \mathrm{d}x \mathrm{d}y</code></td>
<td><script type="math/tex">\displaystyle\iint_{-\infty}^{+\infty} f(x,y) \mathrm{d}x \mathrm{d}y</script></td>
<td>多重积分模式<code>\int、\iint、\iiint、\iiiint、\idotsint</code></td>
<td>$\int、\iint、\iiint、\iiiint、\idotsint$</td>
</tr>
<tr>
<td>微分<code>\frac{\partial x}{\partial y}、\frac{\partial^2x}{\partial y^2}</code></td>
<td>$\frac{\partial x}{\partial y}、\frac{\partial^2x}{\partial y^2}$</td>
<td>其他微分表示：<code>\nabla x</code>、<code>\mathrm{d}x</code>、 <code>\dot x 、\ddot y</code></td>
<td>$\nabla x$、$\mathrm{d}x$、$\dot x$、$\ddot y $</td>
</tr>
<tr>
<td>上下取整：<code>\left \lfloor \frac{a}{b} \right \rfloor</code>、<code>\left \lceil \frac{c}{d} \right \rceil</code></td>
<td>$\left \lfloor \frac{a}{b} \right \rfloor$、$\left \lceil \frac{c}{d} \right \rceil$</td>
<td>长公式<code>\begin{split} x = {} &amp; a + b + c +{}\\            &amp; d + e + f + g \end{split}</code></td>
<td>$\begin{split} x = {} &amp; a + b + c +{}\            &amp; d + e + f + g \end{split}$</td>
</tr>
<tr>
<td>求积<code>\prod_{i=1}^{n} a_i、\displaystyle\prod_{i=1}^{n} a_i</code></td>
<td><script type="math/tex">\prod_{i=1}^{n} a_i</script>、<script type="math/tex">\displaystyle\prod_{i=1}^{n} a_i</script></td>
<td>求和<code>\sum\limits_{i=1}^{n} i^2、\displaystyle \sum_{i=1}^{n}i^2</code></td>
<td>$\sum\limits<em>{i=1}^{n} i^2$、$\displaystyle \sum</em>{i=1}^{n} i^2$</td>
</tr>
<tr>
<td>概率分布<code>\hat{a}</code></td>
<td>$\hat{a}$</td>
<td>虚数<code>\imath、\jmath</code></td>
<td>$\imath、\jmath$</td>
</tr>
<tr>
<td>省略号<code>1,2,\dots  \qquad  1,2,\cdots</code></td>
<td>$ 1,2,\dots  \qquad  1,2,\cdots $</td>
<td>度数<code>90 ^\circ</code></td>
<td>$90 ^\circ$</td>
</tr>
<tr>
<td>矩阵转置<code>\mathbf{A}^\mathrm{T}、\mathbf{A}^\top、\mathbf{A}^\mathsf{T}、\mathbf{A}^\intercal、A^T</code></td>
<td><script type="math/tex">\mathbf{A}^\mathrm{T}</script>,$\mathbf{A}^\top$,$\mathbf{A}^\mathsf{T}$,$\mathbf{A}^\intercal$,$A^T$</td>
<td>字母上箭头<code>\vec{ab} \mbox{ 或 } \overleftarrow{ab} \mbox{ 或 } \overrightarrow{ab}</code></td>
<td><script type="math/tex">\vec{ab} \mbox{ 或 } \overleftarrow{ab} \mbox{ 或 } \overrightarrow{ab}</script></td>
</tr>
<tr>
<td>字母上尖号<code>\hat{A} \mbox{ 或 } \widehat{ABC}</code></td>
<td><script type="math/tex">\hat{A} \mbox{ 或 } \widehat{ABC}</script></td>
<td>字母上波浪线<code>\tilde{A} \mbox{ 或 } \widetilde{ABC}</code></td>
<td><script type="math/tex">\tilde{A} \mbox{ 或 } \widetilde{ABC}</script></td>
</tr>
<tr>
<td>字母上下花括号<code>\overbrace{1+2+3} \mbox{ 或 } \underbrace{1+2+3}</code></td>
<td><script type="math/tex">\overbrace{1+2+3} \mbox{ 或 } \underbrace{1+2+3}</script></td>
<td>字母上方点号<code>\dot{a} \mbox{ 或 } \ddot{a}</code></td>
<td><script type="math/tex">\dot{a} \mbox{ 或 } \ddot{a}</script></td>
</tr>
<tr>
<td>公式组<code>\begin{align} a &amp;=b+c+d \\ x &amp;=y+z\\ 5 &amp;= 4+1 \end{align}</code></td>
<td>$\begin{align} a &amp;=b+c+d \ x &amp;=y+z\ 5 &amp;= 4+1 \end{align}$</td>
<td>分支公式<code>y=\begin{cases} -x,\quad x\leq 0\\ x, \quad x&gt;0 \end{cases}</code></td>
<td>$ y=\begin{cases} -x,\quad x\leq 0\ x, \quad x&gt;0 \end{cases} $</td>
</tr>
<tr>
<td>矩阵1<code>\begin{pmatrix}  a &amp; b\\  c &amp; d \\ \end{pmatrix}  \quad  \begin{bmatrix}  a &amp; b \\  c &amp; d \\ \end{bmatrix}  \quad  \begin{Bmatrix}  a &amp; b \\  c &amp; d \\ \end{Bmatrix}</code></td>
<td>$ \begin{pmatrix}  a &amp; b\  c &amp; d \ \end{pmatrix}  \quad  \begin{bmatrix}  a &amp; b \  c &amp; d \ \end{bmatrix}  \quad  \begin{Bmatrix}  a &amp; b \  c &amp; d \ \end{Bmatrix}  $</td>
<td>矩阵2<code>( \begin{smallmatrix}  a &amp; b \\  c &amp; d  \end{smallmatrix} )  \quad\begin{vmatrix}  a &amp; b \\  c &amp; d \\ \end{vmatrix}  \quad  \begin{Vmatrix}  a &amp; b \\  c &amp; d \\ \end{Vmatrix}</code></td>
<td>$( \begin{smallmatrix}  a &amp; b \  c &amp; d  \end{smallmatrix} )  \quad \begin{vmatrix}  a &amp; b \  c &amp; d \ \end{vmatrix}  \quad  \begin{Vmatrix}  a &amp; b \  c &amp; d \ \end{Vmatrix}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><blockquote>
<p>一下几个字符: # $ % &amp; ~ _ ^ \ { }有特殊意义，需要表示这些字符时，需要转义，即在每个字符前加上 \ 。<br>\boxed命令给公式加一个方框。</p>
</blockquote>
<hr>
<p>  参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/HaleyPKU/article/details/80341932" target="_blank" rel="noopener">https://blog.csdn.net/HaleyPKU/article/details/80341932</a></li>
<li><a href="https://blog.csdn.net/weixin_43159148/article/details/88621318" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43159148/article/details/88621318</a></li>
<li><a href="https://www.jianshu.com/p/8c46e915c45e" target="_blank" rel="noopener">https://www.jianshu.com/p/8c46e915c45e</a></li>
<li><a href="https://blog.csdn.net/qfire/article/details/81382048" target="_blank" rel="noopener">https://blog.csdn.net/qfire/article/details/81382048</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习数学基础</title>
    <url>/2020/03/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h2 id="深度学习数学基础"><a href="#深度学习数学基础" class="headerlink" title="深度学习数学基础"></a>深度学习数学基础</h2><h3 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h3><ol>
<li>泰勒展开</li>
</ol>
<script type="math/tex; mode=display">f(x) = \sum_{n=0}^{\infty}\frac{f^{n}(a)}{n!}(x-a)^{n}</script><p>分别用$x+\epsilon 、x$替换原式中的$x和a$，则有</p>
<p>$f(x+\epsilon)=\sum_{n=0}^\infty\frac{f^n(x)}{n!}(x+\epsilon-x) $</p>
<p>上式可看作$f(x+\epsilon)$在$x$处的泰勒展开，根据导数定义，当$\epsilon \to 0 $ 时，有</p>
<script type="math/tex; mode=display">f^{'}{(x)} = \frac{f(x+\epsilon) - f(x)}{\epsilon}</script><p>则可得到：</p>
<p>$ f(x+\epsilon) = f(x) + f^{‘}(x)\epsilon$</p>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><h5 id="矩阵基础"><a href="#矩阵基础" class="headerlink" title="矩阵基础"></a>矩阵基础</h5><p>矩阵转置：以主对角线为轴的镜像，左上到右下的对角线为主对角线。</p>
<p>$ (\mathbf {A}^\top)<em>{j,i} = \mathbf{A}</em>{i,j} $</p>
<p>单位矩阵：$\forall x\in \mathbf R^n，I_nX=X,其中I^n \in \mathbf R^{n * n}$</p>
<p>矩阵的逆记为$A ^{-1}$,需满足：$A^{-1}A=I_n$</p>
<p>若逆矩阵存在，则$Ax=b$中，对于每一个向量b恰好存在一个解，但是对于方程组而言，对于向量$b$的某些值，有可能无解，或者存在无限多个解。</p>
<p>生成子空间：原始向量线性组合后所能抵达的点的集合。</p>
<p> $Ax=b$是否有解，相当于确定向量$b$是否在$A$列向量的生成子空间中。这个特殊的生成子空间成为$A$的列空间或者$A$的值域。</p>
<h5 id="线性相关，线性无关"><a href="#线性相关，线性无关" class="headerlink" title="线性相关，线性无关"></a>线性相关，线性无关</h5><p>线性无关：如果一组向量中任意一个向量不能表示称其他向量的线性组合，这组向量成为线性无关。</p>
<p>使用矩阵逆求解，必须是方阵或者非奇异的。</p>
<h5 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h5><p>公式：$||x||_p = (\sum_i|x_i|^p)^\frac{1}{p}$，其中$P \in \mathbf R,P \ge 1.$直观上范数衡量从原点到$x$的距离。<br>$L^2$范数成为欧几里得范数（Euclidean norm），经常简写为$||x||$.表示从原点出发到向量$x$确定点的欧氏距离。</p>
<p>另外平方L2范数也经常用来衡量向量大小，更容易计算，$x^ \top x$.对元素的导数只取决于对应的元素，而L2范数对每个原色的导数和整个向量相关。但是平方L2范数在原点福建增长十分缓慢，某些机器学习应用中恰好需要区分零和非零值。此时转而使用在各个位置斜率相同且形式简单的L1范数。</p>
<p>$L^1$范数：$||x||_1 = \sum_i|x_i|$.</p>
<p>有时需要统计向量中非零元素的个数来衡量向量的大小，有些作者将这种函数称为$L^0$范数。但是该术语在数学意义上是不对的。非零数目不是范数，对向量缩放a倍不会改变该向量非零元素数目。因此L1范数经常作为表示非零元素数目的替代函数。<br>另外一个$L \infty $范数，也叫最大范数，公式：$||x||_\infty = max_i|x_i|$.</p>
<p>深度学习中使用Frobenius范数，矩阵中元素平方和再开方。公式为：$||A||<em>F =\sqrt { \sum</em>{i,j}A_{i,j}^2}$<br>两个向量的点击可用范数表示：$x^\top y = ||x||_2||y||_2cos\theta$.</p>
<h5 id="特殊类型矩阵和向量"><a href="#特殊类型矩阵和向量" class="headerlink" title="特殊类型矩阵和向量"></a>特殊类型矩阵和向量</h5><p>对角矩阵：旨在主对角线上含有非零元素，其他位置都是0.</p>
<p>（注意：并非所有对角矩阵都是方阵，非方阵的对角矩阵没有逆矩阵，但是仍然可高效计算乘法。对于长方形对角矩阵$D$,$Dx$会涉及$x$中每个元素的缩放，如果$D_{m*n}$中，m&gt;n,则在缩放后去掉最后一些元素，反之，在末尾添加一些0.）<br>对称矩阵：$A = A^\top$<br>单位向量：具有单位范数的向量，$||x||_2 =1$.<br>正交矩阵：行向量和列向量粉饼标准正交的方阵。$A^\top A=AA^\top=I$.(若$x^\top y=0$，则向量$x$和向量$y$互相正交（orthogonal)，如果两个向量都有非零范数，则夹角是$90^\circ$.在$\mathbf R^n$中至多有$n$个范数非零向量互相正交，若其不但正交且范数都为1，则称为标准正交（orthonormal））。</p>
<h5 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h5><p>将矩阵分解为一组特征向量和特征值<br>$Av=\lambda v$，则称$v$是特征向量，$\lambda$是特征值。</p>
<p>$A$的特征分解：$A = V diag(\lambda) V^{-1}$.并非每个矩阵都可分解成特征值和特征向量，某些情况下，特征分解存在，但是会涉及复述和非实数。很多情况只考虑简单分解的矩阵，即每个实对称矩阵都可分解成特征向量和特征值。</p>
<p>$A = Q \Lambda Q^\top$,其中$Q$是$A$的特征向量组成的正交矩阵，$\Lambda$是对角矩阵。特征分解可能并不惟一。（若两个或多个特征向量拥有相同的特征值，在由这些特征向量产生的生成子空间中，任意一组正交向量都是该特征值对应的特征向量。）</p>
<p>通过特征分解可推导出：矩阵是奇异的当且仅当含有零特征值。</p>
<p>所有特征值都是正数的矩阵称为正定（positive definite），都是非负数的矩阵称为半正定（positive semidefinite).反之为负定、半负定。</p>
<p>半正定矩阵可保证：$\forall x,x ^\top Ax \ge 0.$正定矩阵可保证：$x\top Ax =0则x=0$.</p>
<h5 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h5><p>奇异值分解（singular value decomposition，SVD）是将矩阵分解为奇异向量和奇异值，每个实矩阵都有一个奇异值分解，但不一定都有特征分解。例如非方阵的矩阵无特征分解，此时可用奇异值分解。</p>
<p>$A = UDV^\top$,假设$A$是一个mxn的矩阵，则$U$是mxm，$D$是mxn，$V$是nxn的矩阵。其中$U、V$都是正交矩阵，$D$是对角矩阵，但$D$不一定是方阵。$D$对角线上的元素称为矩阵$A$的奇异值，$U、 V$的列向量分别称为左奇异向量和右奇异向量。</p>
<p>（$A$的左奇异向量是$AA^\top$的特征向量，右奇异向量是$A^\top A$的特征向量，$A$的非零奇异值是$A^\top A$和$AA^\top$特征值的平方根。）</p>
<h5 id="Moore-Penrose伪逆"><a href="#Moore-Penrose伪逆" class="headerlink" title="Moore-Penrose伪逆"></a>Moore-Penrose伪逆</h5><p>非方阵的逆矩阵没有定义，有时需要解如下问题：$Ax=y$,希望求解$A$的左逆$B$来解方程。$x=By$，若矩阵$A_{m*n}$中m&gt;n，则方程可能无解，反之可能有多个解。</p>
<p>Moore-Penrose伪逆 pseudoinverse定义：$A^+ = \lim \limits_{a \searrow 0} (A^\top A + \alpha I)^{-1}A^\top $，但计算时则使用公式：$A^{+}=VD^+U^\top$.其中U、D、V是A奇异值分解后得到的矩阵，对角矩阵D的伪逆$D^+$是其非零元素取倒数之后再转置得到的。</p>
<p>（A中n&gt;m,用伪逆求解线性方程是可能解法之一，$x=A^+y$是所有可行解中欧几里得范数最小的一个。m&gt;n时，可能无解，通过伪逆得到的x使得$||Ax-y||$的欧几里得距离最小。）</p>
<h5 id="迹运算"><a href="#迹运算" class="headerlink" title="迹运算"></a>迹运算</h5><p>迹运算返回的事矩阵对角元素的和：$Tr(A) =\sum<em>iA</em>{i,j}$.</p>
<p>Forbenius范数可表示为：$\left |A \right |_F=\sqrt {Tr(AA^ \top）}$</p>
<p><script type="math/tex">Tr(\prod_{i=1}^nF^{(i)}=Tr(F^{(n)}\prod_{i=1}^{n-1}F^{(i)})</script>.即使循环置换后矩阵成绩得到的矩阵形状变了，但是迹运算结果不变。另外标量迹运算后仍是自己。</p>
<h5 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h5><p>行列式，记为$det(A)$，是将方阵A映射到实数的函数。行列式等于矩阵特征值的乘积。行列式绝对值颗用来衡量矩阵参与矩阵乘法后空间扩大或缩小了多少。</p>
<h5 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h5><p>待补充</p>
<h3 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h3>]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习概览（ML_NG 1）</title>
    <url>/2020/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h3 id="机器学习概览"><a href="#机器学习概览" class="headerlink" title="机器学习概览"></a>机器学习概览</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>机器学习涉及领域较为广泛，可能包含自主机器人、神经生物学等领域</p>
<p>机器学习无论在我们的生活中还是工业生产等方方面面均可发挥作用：</p>
<ul>
<li>医学领域可以辅助进行疾病诊断</li>
<li>交通领域可以让计算机自动学习驾驶</li>
<li>生活中可进行手写识别</li>
<li>网上购物的商品推荐</li>
</ul>
<p>机器学习如今大力发展的原因在于目前产生了非常多的数据，这是机器学习得以发展的土壤。机器学习一般分为监督学习和无监督学习，其他强化学习和推荐系统后续会介绍。</p>
<h4 id="机器学习定义："><a href="#机器学习定义：" class="headerlink" title="机器学习定义："></a>机器学习定义：</h4><blockquote>
<p>Arthur Samuel（1959）Field of study that gives computers the ability to learn without being explicitly programmed.  </p>
<p>在进行特定编程的情况下，给予计算机学习能力的领域</p>
<p>Tom Mitchell (1998) Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and som performance measure P, if its performance on T, as measured by P, improves with experience  E.</p>
<p>计算机程序从经验E中学习，解决某一任务T，进行某一性能度量P，通过P测定在T上的表现因经验E而提高</p>
</blockquote>
<h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>预测房价问题：</p>
<p>一般房子的价格会记到美分，所以房价实际上是一系列离散的值，但是我们通常又把房价看成实数，看成是标量，所以又把它看成一个连续的数值。一般归类为回归问题，即试图推测这一系列连续值的属性。</p>
<p><img src="http://www.ai-start.com/ml2014/images/2d99281dfc992452c9d32e022ce71161.png" alt=""></p>
<p>肿瘤预测问题：</p>
<p>横轴表示肿瘤的大小，纵轴1和0表示是否是恶性肿瘤。这是一个典型的分类问题。试图推测出患者是0还是1这个离散数值。</p>
<p><img src="http://www.ai-start.com/ml2014/images/4f80108ebbb6707d39b7a6da4d2a7a4e.png" alt=""></p>
<p>当然实际问题可能更复杂，不只肿瘤大小这一个特征，问题可能会非常复杂。（思考：如果特征特别多该如何处理？后续SVM课程会给出答案）<img src="http://www.ai-start.com/ml2014/images/c34fa10153f223aa955d6717663a9f91.png" alt=""></p>
<p>简单总结：</p>
<p>监督学习：对于每个样本都想得到正确的结果，即有标注。</p>
<p>回归问题和分类问题：连续的问题，例如房价预测是回归，离散的问题，肿瘤是否良性是分类。</p>
<h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>样本没有任何标签，不知道数据是什么意思，只有一系列数据，要自动学习数据的结构。</p>
<p><img src="http://www.ai-start.com/ml2014/images/0c93b5efd5fd5601ed475d2c8a0e6dcd.png" alt=""><img src="http://www.ai-start.com/ml2014/images/94f0b1d26de3923fc4ae934ec05c66ab.png" alt=""></p>
<p>聚类应用：</p>
<ul>
<li>谷歌新闻关于某一类新闻事件自动聚类</li>
<li>社交网络关系，朋友自动分组</li>
<li>市场细分，判断哪些客户到细分市场销售</li>
<li>天文数据分析星系</li>
</ul>
<p>鸡尾酒问题：分离酒会上的不同声音(0-9)，只需要一行代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[W,s,v] = svd((repmat(sum(x.*x,1),size(x,1),1).*x)*x&apos;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习系列</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习领域的学习资源总结</title>
    <url>/2020/03/01/ML%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>机器学习领域的学习资源总结：</p>
<p>频率派 —— 统计机器学习<br>贝叶斯派 —— 概率图模型</p>
<p>参考书推荐：<br>1.李航 《统计学习方法》<br>第一版：感K朴决逻，支提E隐条 ————&gt; 统计机器学习</p>
<p>第二版：增加大量无监督学习算法，包括，聚类、奇异值分解、主成分分析、潜在语义分析、MCMC、LDA、PageRank等</p>
<p>2.周志华 《机器学习》西瓜书</p>
<p>3.PRML《模式识别与机器学习》<br>主要是以贝叶斯的角度：<br>回分神核稀，图混近采连 顺 组</p>
<p>4.MLAPP 《以概率的视角去看机器学习》<br>百科全书似的，主要以贝叶斯角度</p>
<p>5.ESL《统计学习的基本元素》<br>主要以频率派的角度阐述，倾向性比较明显</p>
<p>6.Deep Learning 《深度学习》圣经 张志华团队翻译</p>
<p>视频资料：</p>
<p>1.台湾大学：林轩田<br>1）机器学习基石：VC Theory、正则化、线性模型等。（非常精彩）<br>2）机器学习技法：SVM、决策树、随机森林、神经网络、DeepLearning等算法模型。</p>
<p>2.张志华：<br>1）机器学习导论：主要是以频率派的角度阐述<br>2）统计机器学习：主要讲统计上的一些理论，以贝叶斯的角度阐述，偏数学方面。</p>
<p>3.Ng:CS229 斯坦福大学2017</p>
<p>4.徐亦达：<br>阐述一些列概率模型，EM、MCMC、Calman Filter，粒子滤波，狄利克雷过程。深度很深不多。<br>GitHub ——&gt; notes 很全！链接地址：</p>
<p>5.台湾大学：李宏毅<br>1）机器学习（2017）CNN、DNN<br>2）MLDS（2018）优化、正则化、实践优化、自然语言处理等</p>
<p>6.白板机器学习视频</p>
<p>视频地址：</p>
<p>笔记：<a href="https://github.com/shuhuai007/Machine-Learning-Session" target="_blank" rel="noopener">https://github.com/shuhuai007/Machine-Learning-Session</a></p>
<p>数学基础：</p>
<p>王维克，数学之旅，宏观层面理解，不涉及具体公式推导。 <a href="https://www.bilibili.com/video/BV1u7411A7Pb?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1u7411A7Pb?p=2</a></p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>预训练语言模型梳理</title>
    <url>/2020/02/29/%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h4 id="自然语言处理范式总结"><a href="#自然语言处理范式总结" class="headerlink" title="自然语言处理范式总结"></a>自然语言处理范式总结</h4><p>范式就是规范的意思，在自然语言处理领域目前总共可分为四个里程碑及四个范式，分别为：</p>
<p><img src="https://www.msra.cn/wp-content/uploads/2020/01/2019-review-nlp-speech-1.png" alt=""></p>
<ol>
<li>第一个范式为1990年以前的处理方法，基本为字典／词典辅以规则</li>
<li>第二个范式主要是2000-2012年的统计机器学习模型</li>
<li>第三个范式则是以深度学习为代表的模型，端到端的神经网络模型</li>
<li>第四个范式是以预训练语言模型加微调为主，再进行模型压缩</li>
</ol>
<a id="more"></a>
<h4 id="详尽的预处理模型关系图"><a href="#详尽的预处理模型关系图" class="headerlink" title="详尽的预处理模型关系图"></a>详尽的预处理模型关系图</h4><p><img src="https://pic1.zhimg.com/v2-447ae7707604e7ac520555249332c42c_1200x500.jpg" alt=""></p>
<ol>
<li>预训练语言模型</li>
</ol>
<p>模型可以通过监督学习方法获得，这是最常规的统计学习思路</p>
<p>今年来涌现的预训练语言模型则可利用三种不同类型的数据学习得到模型：</p>
<ul>
<li>生文本：通过自监督学习（self-supervised learning）得到预训练模型</li>
<li>辅助任务标注数据：通过预训练（pre-training）得到预训练模型</li>
<li>标注数据：通过精调（fine-tuning）得到预训练模型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Tonyan/BlogPicBed/master//img/预训练模型.png" alt=""></p>
<h4 id="词向量时代"><a href="#词向量时代" class="headerlink" title="词向量时代"></a>词向量时代</h4><h4 id="预训练语言模型时代"><a href="#预训练语言模型时代" class="headerlink" title="预训练语言模型时代"></a>预训练语言模型时代</h4><h5 id="预处理范式时间轴"><a href="#预处理范式时间轴" class="headerlink" title="预处理范式时间轴"></a>预处理范式时间轴</h5><p><img src="https://www.msra.cn/wp-content/uploads/2020/01/2019-review-nlp-speech-2.png" alt=""></p>
<h5 id="各种预处理语言模型发展关系图"><a href="#各种预处理语言模型发展关系图" class="headerlink" title="各种预处理语言模型发展关系图"></a>各种预处理语言模型发展关系图</h5><p><img src="https://static.leiphone.com/uploads/new/images/20191031/5dba851bec6e1.png?imageView2/2/w/740" alt=""></p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ol>
<li><a href="http://ir.hit.edu.cn/~car/talks/pre-training4nlp.pdf" target="_blank" rel="noopener">预训练模型-自然语言处理的新范式 </a></li>
<li><a href="https://www.msra.cn/zh-cn/news/features/2019-review-nlp-speech" target="_blank" rel="noopener">NLP新范式凸显跨任务、跨语言能力，语音处理落地开花</a></li>
<li><a href="https://www.leiphone.com/news/201910/VIRhfQaQERfRedvB.html" target="_blank" rel="noopener">NLP领域预训练模型的现状及分析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93781241" target="_blank" rel="noopener">预训练语言模型(PLMs)走的飞快</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/85221503" target="_blank" rel="noopener">NLP预训练模型：从transformer到albert</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/76912493" target="_blank" rel="noopener">nlp中的预训练语言模型总结(单向模型、BERT系列模型、XLNet)</a></li>
<li><a href="http://www.xuwei.io/2018/11/20/nlp的巨人肩膀/" target="_blank" rel="noopener">NLP的巨人肩膀</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>深度学习系列</category>
      </categories>
      <tags>
        <tag>DL</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Latex公式支持</title>
    <url>/2016/11/22/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E6%94%AF%E6%8C%81latex%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>sublime texta安装markdown editing preview插件（ctrl+shift+p）输入install，在弹出窗口中输入需安装插件名称，回车即可，安装后ctrl+b运行即可在本地生成html文件预览。</li>
<li>markdown文件头部填入以支持MathJax引擎（用图片解析或者接口方式发现速度太慢）</li>
</ol>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>加入之后在本地发现可支持，但是用hexo部署至自己的博客系统不支持，发现有人实现了一个<a href="http://blog.csdn.net/xiahouzuoxin/article/details/26478179" target="_blank" rel="noopener">插件</a><br> 安装 <code>npm install hexo-math --save</code></p>
</li>
<li><p>此处需要注意，不要在_config.yml中添加关于该插件的配置信息，因为它会自动生成</p>
</li>
<li><p>我安装完之后运行依然没有实现公式效果，发现再安装一个插件即可解决<br> <code>npm install hexo-renderer-mathjax --save</code></p>
</li>
<li><p>以下为公式测试<br> 行内公式：Simple inline $a = b + c$.</p>
<p>段间公式：</p>
<script type="math/tex; mode=display">\frac{\partial u}{\partial t}
= h^2 \left( \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} +
\frac{\partial^2 u}{\partial z^2}\right)</script><p>至此终于完美的解决了问题，好开心，哈哈</p>
</li>
<li><p>还有个小技巧，Sublime Text安装LiveReload同时chrome浏览器也安装该插件，即可在运行<code>hexo -s</code>之后同步调试，可视化码字，简直不能再爽啦O(∩<em>∩)O~~</em>)解决完所有问题下面该专注内容本身啦，加油！！</p>
</li>
</ol>
<p>注意：2022年重新部署发现问题有更改配置参考<a href="https://blog.csdn.net/littlehaes/article/details/84370393" target="_blank" rel="noopener">https://blog.csdn.net/littlehaes/article/details/84370393</a></p>
<p>可能不改也可以？如果出现问题再更改回去</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
